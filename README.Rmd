---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# railvarr

<!-- badges: start -->

[![R-CMD-check](https://github.com/sebmerricks/railvarr/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/sebmerricks/railvarr/actions/workflows/R-CMD-check.yaml)

<!-- badges: end -->

The goal of `railvarr` is to ...

## Installation

You can install the development version of `railvarr` from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("sebmerricks/railvarr")
```

## Pipeline

`railvarr` implements 5 key processing steps for the analysis of Centrix data.

### 1. Centrix Processing

In this step, the raw Centrix data are converted into human-readable berth-level observations, including labeling train IDs. This step also removes anomalies and invalid data. Up to around 5% of the data can be lost. The main function you will need for this step is [wrangle_centrix()](https://sebmerricks.github.io/railvarr/reference/wrangle_centrix.html). There are three inputs for this step:

#### 1. Raw Centrix data

Centrix observations consist of four data points:

-   `asset` a character string containing the asset ID
-   `state` a character string representing the state of the asset
-   `dt` the date and time at which the event took place
-   `transition` the state transition that caused the event

For example, a train entering track `'TA-1'` on the 2nd January 2020 at 17:03 would produce the following Centrix observation:

```{r echo = FALSE}
dplyr::tribble(
  ~asset, ~state, ~dt, ~transition,
  "TA-1", "TR", lubridate::as_datetime("2020-01-02 17:03:00"), "UP to DN"
)
```

The state `'TR'` is simply a placeholder, because this observation relates to a track asset. The state component is only relevant for signal events, in which case it represents the signal aspect. The transition `'UP to DN'` represents a train entering the track, while a transition of `'DN to UP'` would represent a train exiting the track.

#### 2. Asset mapping

The asset mapping is a representation of the track section. Currently, the track is represented by a linear data frame. However, this does not support more complex track layouts like junctions. The asset map should contain a 1-1 mapping from signal ID to berth name, a 1-many mapping from berth name to track ID, and an extra `event` column. For example, a simple track section with two berths, two signals, and three tracks would be:

```{r echo = FALSE}
dplyr::tribble(
  ~signal, ~berth, ~track, ~event,
  "S1", "A", "TA-1", "enters",
  "S1", "A", "TA-1", "vacates",
  "S1", "A", "TA-2", "enters",
  "S1", "A", "TA-2", "vacates",
  "S2", "B", "TB", "enters",
  "S2", "B", "TB", "vacates"
)
```

The `event` column represents the fact that there are separate Centrix observations for trains entering and exiting a track. Therefore, each track can have both an `'enters'` and `'vacates'` event associated with it. In order to calculate berth travel times, it is necessary to know when a train entered the following berth. However, if we used the asset map given above, we would not include data for the `'enters'` event at signal `'S3'`. Therefore, we would not be able to calculate travel times for `'S2'`. If these travel time calculations are important, it is recommended to include the extra event in the asset map:

```{r echo = FALSE}
dplyr::tribble(
  ~signal, ~berth, ~track, ~event,
  "S3", "C", "TC", "enters"
)
```

#### 3. State mapping

The state mapping provides a 1-1 mapping from signal state codes to signal aspects. This is standardised, so `railvarr` provides a default mapping that you can access by running

```{r}
data(state_mapping)
state_mapping
```

See [this website](https://wiki.openraildata.com/index.php/Signalling_Nomenclature#Signals) for other codes.

### 2. Centrix Clustering

Raw Centrix data contains no information about train types or stopping patterns. However, knowledge of these stopping patterns is useful for analysis and it is pre-requisite to the ID matching process. `railvarr` provides functionality for clustering by travel time. Specifically, K-Means Clustering is used. Currently, this implementation does not support outlier detection. However, you can perform your own outlier detection and give a list of outliers to the clustering function in order to remove those observations from the analysis. See [cluster_journeys()](https://sebmerricks.github.io/railvarr/reference/cluster_journeys.html) for more information.

### 3. Timetable Processing

This step filters the timetable to only include relevant services, travelling in the correct direction. It also calculates and attaches calling patterns. The main `railvarr` function you will need for this is [wrangle_timetable()](https://sebmerricks.github.io/railvarr/reference/wrangle_timetable.html). Three inputs are required:

#### 1. Raw Timetable

Your timetable must match the expected structure. This consists of 8 data points:

-   `train_header` the train identifier, usually some from of [headcode](https://www.rail-record.co.uk/understanding-a-headcode/)
-   `dt_origin` the date and time at which the train originated; this forms a train's unique identifier when combined with the `train_header`
-   `geo` the location at which the timetable event is taking place, usually stations and TIPLOcs like junctions
-   `event` the type of event; this can only be one of the following: `"Pass"`, `"Arrive"`, `"Depart"`, `"Originate"`, `"Terminate"`
-   `wtt` the scheduled date and time of the event
-   `t` the actual date and time of the event
-   `delay` the difference between the actual time and the scheduled time of the event
-   `allow` the timetable delay allowance; this indicates whether delays should be expected

For example, a train with the headcode `'1A23'` originating at 14:17 on the 23rd May 2020 could have the following timetable entry for the station `'Example'`

```{r echo = FALSE}
dplyr::tribble(
  ~train_header, ~dt_origin, ~geo, ~event, ~wtt, ~t, ~delay, ~allow,
  "1A23", lubridate::as_datetime("2020-05-23 14:17:00"), "Example", "Arrive", lubridate::as_datetime("2020-05-23 14:37:00"), lubridate::as_datetime("2020-05-23 14:36:00"), -1, 0,
  "1A23", lubridate::as_datetime("2020-05-23 14:17:00"), "Example", "Depart", lubridate::as_datetime("2020-05-23 14:37:30"), lubridate::as_datetime("2020-05-23 14:37:00"), -0.5, 0
)
```

This timetable entry indicates that the train arrived at the station 1 minute early and departed 30 seconds early. However, it is important to note that timings in the timetable are usually rounded, either to the nearest 15 or 30 seconds.

#### 2. Stations

You should provide a list of stations that you are interested in. For example, a train may stop at many stations on its journey, but your Centrix data only covers a small subset of that journey. Therefore, you should provide a list of stations that completely encompasses your Centrix data. This ensures that all relevant services are included in the processed timetable. However, you may need to ensure that no irrelevant services are accidentally included. If you are using [wrangle_timetable()](https://sebmerricks.github.io/railvarr/reference/wrangle_timetable.html), the order in which you define this list is important, because it specifies the direction in which trains should be travelling. This allows for the filtering of services by direction. You can avoid this by using the lower level functions directly, but these functions do not currently come with input validation, so discretion is advised.

#### 3. Stopping Stations

This is a list of only those stations which are covered by the Centrix data. For example, imagine you have the following track layout:

\|--------\[Stop 1\]--------(Centrix start)\|----------\[Stop 2\]-----------\|(Centrix end)-----------\[Stop 3\]------------\|

The first list should include all three stations in order to capture all trains which use the track included in the Centrix data. However, because only Station 2 is actually included in the Centrix data, this second list should contain only this station. This second list is used to calculate calling patterns, so any trains which do not stop at any of the stations in the list will be labeled as `'fast'` trains. In the above example, trains which stop at Station 1 and Station 3, but not Station 2, would be labeled as `'fast'`.

### 4. ID Matching

The ID matching algorithm matches Centrix IDs with corresponding timetable IDs. This is necessary because raw Centrix data contain no identification information. Furthermore, there can be mismatches, where Centrix says there are trains present when the timetable doesn't, and vice-versa. An extra input is required here, containing instructions for the matching process. For more details, see [match_ids()](https://sebmerricks.github.io/railvarr/reference/match_ids.html) and the [ID Matching section of the Get Started page](https://sebmerricks.github.io/railvarr/articles/railvarr.html#id-matching).

### 5. Dwell Time and Delays



![Diagram of the processing pipeline that `railvarr` provides](man/figures/README-pipeline.PNG)

## Getting Started

The first step is to massage your raw data into the correct structure, as `railvarr` provides no reading functionality.

### Centrix

A detailed overview of what is expected for Centrix data can be found in [wrangle_centrix()](https://sebmerricks.github.io/railvarr/reference/wrangle_centrix.html). Here is an example of a valid Centrix data frame:

```{r raw_centrix}
data(raw_centrix)
head(raw_centrix, 10)
```

## Timetable

A detailed overview of what is expected for Timetable data can be found in [wrangle_timetable()](https://sebmerricks.github.io/railvarr/reference/wrangle_timetable.html). Here is an example of a valid Timetable data frame:

```{r raw_timetable}
data(timetable)
head(timetable, 10)
```
